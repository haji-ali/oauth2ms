#!/usr/bin/env python3
# Copyright 2020 Harish Krupo
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#     http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from xdg.BaseDirectory import save_data_path
import argparse
import webbrowser
import json
import msal

from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs, urlencode
from wsgiref import simple_server
import wsgiref.util
import git
import sys
import uuid
import os
import base64
import gnupg
import io
import passpy
import urllib

def parse_key(key):
    # Copied from pass_import/managers/passwordstore.py
    # function show(.,.)
    entry = {}
    try:
        data = key.split('\n')
    except UnicodeDecodeError:
        entry['data'] = self._command(['show', path], nline=False)
        return entry

    data.pop()
    if data:
        line = data.pop(0)
        if ': ' in line:
            (key, value) = line.split(': ', 1)
            entry[key] = value
        else:
            entry['password'] = line
    for line in data:
        if ': ' in line:
            (key, value) = line.split(': ', 1)
            if key in entry:
                if isinstance(entry[key], list):
                    entry[key].append(value)
                else:
                    entry[key] = [entry[key], value]
            else:
                entry[key] = value
        elif line.startswith('otpauth://'):
            entry['otpauth'] = line
        elif 'comments' in entry:
            entry['comments'] += '\n' + line
    return entry

class WSGIRequestHandler(wsgiref.simple_server.WSGIRequestHandler):
    """Silence out the messages from the http server"""
    def log_message(self, format, *args):
        pass

class WSGIRedirectionApp(object):
    """WSGI app to handle the authorization redirect.
    Stores the request URI and displays the given success message.
    """
    SUCCESS_MESSAGE = "Authorization complete."
    def __init__(self, message):
        self.last_request_uri = None
        self._success_message = message

    def __call__(self, environ, start_response):
        start_response("200 OK", [("Content-type", "text/plain; charset=utf-8")])
        self.last_request_uri = wsgiref.util.request_uri(environ)
        return [self._success_message.encode("utf-8")]

def build_msal_app(config, cache=None):
    return msal.ConfidentialClientApplication(
        config['client_id'],
        authority=config['authority'],
        client_credential=config['client_secret'],
        token_cache=cache)

def build_new_app_state(config, no_browser=False):
    cache = msal.SerializableTokenCache()
    state = str(uuid.uuid4())
    auth_url = build_msal_app(config, cache).get_authorization_request_url(
        config['scopes'],
        state=state,
        redirect_uri=config["redirect_uri"])
    wsgi_app = WSGIRedirectionApp(WSGIRedirectionApp.SUCCESS_MESSAGE)
    redirect_host, redirect_port = urllib.parse.urlparse(
        config["redirect_uri"]).netloc.split(":")
    http_server = simple_server.make_server(redirect_host,
                                            int(redirect_port),
                                            wsgi_app,
                                            handler_class=WSGIRequestHandler)
    if no_browser:
        print("Please navigate to this url: " + auth_url, file=sys.stderr)
    else:
        webbrowser.open(auth_url, new=2, autoraise=True)

    http_server.handle_request()
    auth_response = wsgi_app.last_request_uri
    http_server.server_close()
    parsed_auth_response = parse_qs(auth_response)

    code_key = config["redirect_uri"] + "?code"
    if code_key not in parsed_auth_response:
        return None

    auth_code = parsed_auth_response[code_key]
    result = build_msal_app(config, cache).acquire_token_by_authorization_code(
        auth_code,
        scopes=config['scopes'],
        redirect_uri=config["redirect_uri"]);

    if result.get("access_token") is None:
        print("Something went wrong during authorization", file=sys.stderr)
        print("Server returned: {}".format(result), file=sys.stderr)
        return None

    return ({"config":config, "cache":cache},
            result["access_token"])

def build_app_state_from_credentials(credentials, config):
    # Make sure it is a valid json object
    try:
        cache = msal.SerializableTokenCache()
        cache.deserialize(credentials)
    except:
        print("Not a valild json file or it is ecrypted. Maybe add/remove the -e arugment?", file=sys.stderr)
        sys.exit(1)

    return {"config":config, "cache":cache}

def encode_xoauth2(app, token):
    """
    Encode the xoauth 2 message based on:
https://docs.microsoft.com/en-us/exchange/client-developer/legacy-protocols/how-to-authenticate-an-imap-pop-smtp-application-by-using-oauth#sasl-xoauth2
    """
    config = app['config']
    cache = app['cache']
    cca = build_msal_app(config, cache)
    accounts = cca.get_accounts()
    username = accounts[0]["username"]
    C_A = b'\x01'
    user = ("user=" + username).encode("ascii")
    btoken = ("auth=Bearer " + token).encode("ascii")
    xoauth2_bytes = user + C_A + btoken + C_A + C_A
    return base64.b64encode(xoauth2_bytes).decode("utf-8")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--auth-key", action="store", default="oauth2ms",
                        help="Path to pass key where all info is stored")
    parser.add_argument("--token-key", action="store", default="oauth2ms",
                        help="Path to pass key where all info is stored")
    parser.add_argument("--encode-xoauth2", action="store_true", default=False,
                        help="Print xoauth2 encoded token instead of the plain token")
    parser.add_argument("--no-browser", action="store_true", default=False,
                        help="Don't open a browser with URL. Instead print the URL. Useful inside virtualized environments like WSL.")

    cmdline_args = parser.parse_args()
    pass_store = passpy.Store()

    config = parse_key(pass_store.get_key(cmdline_args.auth_key))
    required_keys = ["authority", "client_id", "redirect_uri", "scopes",
                     "client_secret"]
    if (config is None or not all([x in config for x in required_keys])):
        print("Invalid config\nConfig must contain the keys: {}".format(required_keys),
              file=sys.stderr)
        sys.exit(1)

    token = None
    app_state = None
    try:
        cache_key = pass_store.get_key(cmdline_args.token_key)
        app_state = build_app_state_from_credentials(cache_key, config)
        cca = build_msal_app(app_state['config'], app_state['cache'])
        accounts = cca.get_accounts()
        if accounts:
            token = cca.acquire_token_silent(config['scopes'],
                                             account=accounts[0])["access_token"]
    except FileNotFoundError:
        pass

    if app_state is None:
        app_state, token = build_new_app_state(config, cmdline_args.no_browser)
        if app_state is None:
            print("Something went wrong!", file=sys.stderr)
            sys.exit(1)

    if cmdline_args.encode_xoauth2:
        print(encode_xoauth2(app_state, token))
    else:
        print(token);

    cache = app_state['cache']
    if cache.has_state_changed:
        try:
            pass_store.set_key(cmdline_args.token_key, cache.serialize(), True)
        except git.exc.GitCommandError as e:
            print(e, file=sys.stderr)

if __name__ == "__main__":
    main()
